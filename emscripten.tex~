\chapter{Emscripten入門と実践}
\label{chap:emscripten}

Emscriptenとはc、c++のコードやLLVMバイトコードを
JavaScriptに変換するプロダクトとして有名ですよね？
ただ、日本語の情報が少なく導入の部分で躓く人が多いと思います。
ここではEmscriptenを動作させるための環境構築から、
コマンドラインツールを変換するまでを順を追って解説します。


\section{環境構築}

まずはemscriptenを動作させるための環境構築を行います。
ここではubuntu12.04 64bit版を前提とします。
windowsやmacをお使いの方は仮想環境を作成してください。

\subsection{最低限必要なツールをインストール}

Emscriptenを使う際に必要なツールをインストールします。

\begin{lstlisting}[style=command]
$ sudo apt-get install -y git default-jre curl nodejs make
\end{lstlisting}


\subsection{LLVMのインストール}

執筆時点でのEmscriptenに対応している最新版である
LLVM3.2をインストールします。
ubuntu12.04用のLLVMバイナリが用意されていますので、
ダウンロードして展開するだけです(ソースからコンパイルする場合は
そこそこ時間がかかりますので)。

\begin{lstlisting}[style=command]
$ curl http://llvm.org/releases/3.2/clang+llvm-3.2-x86_64-li\
nux-ubuntu-12.04.tar.gz | tar -xz
\end{lstlisting}

\subsection{emscriptenのインストール}

\subsubsection*{emscriptenの入手}

emscriptenはgithubから入手します。
emscriptenのレポジトリが保存されたディレクトリへのパスも
通しておきましょう。

\begin{lstlisting}[style=command]
$ git clone git@github.com:kripken/emscripten.git
\end{lstlisting}

\subsubsection*{.emscriptenの編集}

何もオプションなどをいれずに\texttt{emcc}コマンドを実行します。
すると、ホームディレクトリに
.emscriptenというファイルが作成されます。
このファイルはemscriptenの各ツールを動かすための設定を行なっています。
最低限\texttt{EMSCRIPTEN\_ROOT}と\texttt{LLVM\_ROOT}だけは設定してください。
以下設定例。

\begin{lstlisting}
import os

# emscriptenのレポジトリのパス
EMSCRIPTEN_ROOT = os.path.expanduser('~/emscripten')

# ダウンロードしたLLVMのbinディレクトリのパス
LLVM_ROOT = os.path.expanduser('~/clang+llvm-3.2-x86_64-linux-ubuntu-12.04/bin')

# ...以下略
\end{lstlisting}

\section{Hello world!}

最初に動かすプログラムと言ったらhello worldです。
以下のようなcファイル(hello.c)を用意しましょう。

\begin{lstlisting}
#include <stdio.h>

int main(void) {
  printf("Hello world!");
}
\end{lstlisting}

このhello.cを\texttt{emcc}コマンドを使ってコンパイルします。

\begin{lstlisting}[style=command,language=Sh]
$ emcc hello.c -o hello.html
\end{lstlisting}

見てわかるように、\texttt{-o} オプションで出力するファイル名を設定することができます。
拡張子によって出力するファイルの種類を自動的に決めてくれます。
出力されたhello.htmlを開くと画面の下の方にhello worldと表示されているはずです。

\section{コマンドラインツールを変換する}

emscriptenで変換されるもの中でも最も多いのはゲーム
かコマンドラインツールでしょう。
ゲームをJavaScriptに変換するのはかなり骨が折れる作業ですが、
ネイティブのコマンドラインツールを
JavaScriptに移植することは比較的簡単で、
しかも意外に実用レベルのものができます。
ここでは例としてzlib(に含まれるzpipe.c)を
JavaScriptの関数として使えるようにしてみましょう。

\subsection{準備}

チュートリアル用のレポジトリをgithubに用意したのでそこから
ダウンロードします。

\begin{lstlisting}[style=command]
$ git clone hogehoge
\end{lstlisting}

\subsubsection*{レポジトリの構成}

レポジトリのディレクトリ構成は以下のようになっています。

\begin{lstlisting}[style=command]
.
├── Gruntfile.coffee
├── dist
├── package.json
├── src
├── test
└── zlib
\end{lstlisting}

\begin{itemize}
 \item \textbf{Gruntfile.coffee} - gruntのビルドファイルです
 \item \textbf{dist} - emscriptenによって生成されたファイルを置きます
 \item \textbf{package.json} - 主にgruntの依存ファイルを記述しています
 \item \textbf{src} - 後で開設するソースコードを置いています
 \item \textbf{test} - テストコードを置いています
 \item \textbf{zlib} - zlibのソースコード一式が置いています
\end{itemize}

特に注釈がない場合、カレントディレクトリは
レポジトリのルートとします。

\subsection{zlibのビルド}

ネイティブのアプリケーションのように
\texttt{configure}、\texttt{make}します。
ただし、emscriptenでは\texttt{configure}の替わりに
\texttt{emconfigure}コマンドを使います。

\begin{lstlisting}[style=command]
$ cd zlib
$ emconfigure ./configure
$ make
\end{lstlisting}

zlibの場合は特に問題なく上手く行きますが、
ものによっては手を加えないとビルドすら通らないものもあります。

\subsection{zpipe.cのビルド}

zpipe.cは標準入力をzlib形式で圧縮・展開する
コマンドラインツールです。これを\texttt{emcc}コマンドで
ビルドします。

\begin{lstlisting}[style=command]
$ # 圧縮
$ zpipe < foo.txt > foo.txt.zlib
$ # 展開
$ zpipe -d < foo.txt.zlib > foo.txt
\end{lstlisting}

ネイティブのアプリケーションと同じように
ビルドにはlibz.aを含めます。

\begin{lstlisting}[style=command]
$ emcc zlib/examples/zpipe.c zlib/libz.a -o dist/zpipe.raw.js
\end{lstlisting}

一応ビルドすることは出来ました。
しかし、これをブラウザで実行しても
標準入出力からファイルを扱ったり、
オプションを受け取ることはできません。

\subsection{ブラウザで動くようにする}

emscriptenで変換されたcファイルは、
ヒープメモリ領域の確保など環境構築を行なって
main関数を呼ぶまでの一連の動作を行います。
つまり、この処理を関数の内部に内包するようにラップしてやると
呼び出しごとにmain関数の処理を行うことができます。

\begin{lstlisting}
var foo = (function() {
  function run(args, inputBytes) {
    var Module = {
      arguments: args
    };
    /* ここにemscriptenで生成されたコードを入れます */
    return hogehoge;
  }

  return {
    api1: run.bind(null, args1),
    api2: run.bind(null, args2)
  }:
})();
\end{lstlisting}


オプションや標準入出力をどのように扱うかは\js{Module}オブジェクト
のプロパティとして定義します。
オプションは\js{Module.arguments}に文字列の配列を定義します。
標準入力は\js{Module.stdin}に1byteの数値を返す関数を定義します。
標準出力は\js{Module.stdout}に1byteの数値を受け取る関数を定義します。

emscriptenで標準入出力系のコマンドラインツールを変換したものを
使えるようにしたAPIを作るには
基本的に入出力にTypedArray(特にUint8Array)を使います。
以下は今回使うファイルです。
見た目の都合上、一緒に書きます。

\begin{lstlisting}
/* header.js */
var zpipe = (function() {
  function run(decompress, inputBytes) {
    var inputIndex, outputIndex, outputBytes, Module;
    
    inputIndex = 0;
    outputIndex = 0;
    outputBytes = new Uint8Array(0x8000);
    Module = {
      arguments: decompress ? ['-d'] : [],
      // 標準入力を1byteずつ読みだす
      stdin: function() {
        return inputBytes[inputIndex++];
      },
      // 標準出力に1byteずつ書きこむ
      stdout: function(x) {
        if (x === null) return;
        if (outputIndex === ouputBytes.length) {
          tmp = new Uint8Array(outputBytes.length * 2);
          tmp.set(outputBytes);
          outputBytes = tmp;
        }
        outputBytes[outputIndex] = x;
      }
    };
    
/* footer.js */
    return new Uint8Array(outputBytes.buffer.slice(0, outputIndex));
  };
  
  return {
    compress: run.bind(null, false),
    decompress: run.bind(null, true)
  };
})();
\end{lstlisting}

ファイルを連結します。

\begin{lstlisting}[style=command]
$ cat header.js dist/zpipe.raw.js src/footer.js > dist/zpipe.js
\end{lstlisting}

これで\js{zpipe.compress}、\js{zpipe.decompress}から
圧縮・展開できるようになりました。

\begin{lstlisting}
var comped = zpipe.compress(input);
var decomped = zpipe.decompress(comped);
\end{lstlisting}


\section{最適化}

\subsection{emccの最適化オプション}

\texttt{emcc}コマンドを使うとき、
\texttt{-O2}オプションを使うことでコードが最適化されます。
具体的には、
asm.js仕様への準拠、
relooperアルゴリズムによる最適化、
Closure Compilerによるコードのminifyなどが行われます
(オプションとして\texttt{--closure 0}を付加するとminifyされません)。

\begin{lstlisting}[style=command]
$ # O2オプションでの最適化
$ emcc -O2 foo.c -o foo.js
$ # --closure 0 でminify無効化
$ emcc -O2 --closure 0 foo.c -o foo.js
\end{lstlisting}

\subsection{環境構築を一回だけ行う}

main関数を呼ぶまでの前処理を一回だけ行なって
API呼び出しごとにmain関数だけ呼び出すという方法です。
main関数が呼ばれないようにするには
\js{Module.noInitialRun}フラグを{\jstrue}にします。
手動でmain関数を呼ぶには\js{Module.callMain}メソッドを呼び出します。
引数にはオプションとして文字列の配列を渡します。

\begin{lstlisting}
/* header.js */
var zpipe = (function() {
  var inputIndex, outputIndex, Module, outputBytes, Module;

  outputBytes = new Uint8Array(0x8000);
  Module = {
    'noInitialRun': true,
    'stdin': function() {
      return inputBytes[inputIndex++];
    },
    'stdout': function(x) {
      if (x === null) return;
      if (outputIndex === ouputBytes.length) {
        var tmp = new Uint8Array(outputBytes.length * 2);
        tmp.set(outputBytes);
        outputBytes = tmp;
      }
      outputBytes[outputIndex] = x;
    }
  };

  /* emscripten code */

/* footer.js */
  /*
  実際に呼び出される関数。
  indexの初期化はここで行う。
  */
  function zpipeRun(decompress, inputBytes) {
    inputIndex = 0;
    outputIndex = 0;
    Module.callMain(decompress);
    return new Uint8Array(outputBytes.buffer.slice(0, outputIndex));
  }

  return {
    compress: zpipeRun.bind(null, []),
    decompress: zpipeRun.bind(null, ['-d'])
  };
})();
\end{lstlisting}

\subsection{入出力処理を最適化する}

emscriptenでは実際の入出力処理は
\js{_read}、\js{_write}関数から行われます。
この中で入出力1byteごとに\js{Module.input}、\js{Module.output}
に登録した関数が呼び出されます。
これを\js{Uint8Array.prototype.set}メソッドで
一気に入出力処理を行うことで高速化を図ります。

これはどちらかというと正攻法ではないのですが、
そういうこともできるということで。



\section{Gruntタスク}

本書で行ったコンパイル、ファイル連結などはGruntfile.coffee
にGruntタスクとして登録してあります。

\begin{itemize}
 \item grunt
\end{itemize}


\begin{lstlisting}[style=command]
$ emcc -O2 foo.c
\end{lstlisting}
